//////////////////////////////////////////////////////////////////
// (c) Copyright 2003-  by Jeongnim Kim
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//   National Center for Supercomputing Applications &
//   Materials Computation Center
//   University of Illinois, Urbana-Champaign
//   Urbana, IL 61801
//   e-mail: jnkim@ncsa.uiuc.edu
//
// Supported by
//   National Center for Supercomputing Applications, UIUC
//   Materials Computation Center, UIUC
//////////////////////////////////////////////////////////////////
// -*- C++ -*-
#include "QMCWaveFunctions/Fermion/MultiSlaterDeterminantFast.h"
#include "QMCWaveFunctions/Fermion/MultiDiracDeterminantBase.h"
#include "ParticleBase/ParticleAttribOps.h"

namespace qmcplusplus
{

MultiSlaterDeterminantFast::MultiSlaterDeterminantFast(ParticleSet& targetPtcl, MultiDiracDeterminantBase* up, MultiDiracDeterminantBase* dn):
  RatioTimer("MultiSlaterDeterminantFast::ratio"),
  RatioGradTimer("MultiSlaterDeterminantFast::ratioGrad"),
  RatioAllTimer("MultiSlaterDeterminantFast::ratio(all)"),
  Ratio1Timer("MultiSlaterDeterminantFast::detEval_ratio"),
  Ratio1GradTimer("MultiSlaterDeterminantFast::detEval_ratioGrad"),
  Ratio1AllTimer("MultiSlaterDeterminantFast::detEval_ratio(all)"),
  UpdateTimer("MultiSlaterDeterminantFast::updateBuffer"),
  EvaluateTimer("MultiSlaterDeterminantFast::evaluate"),
  AccRejTimer("MultiSlaterDeterminantFast::Accept_Reject")
{
  registerTimers();
  //Optimizable=true;
  Optimizable=true;
  OrbitalName="MultiSlaterDeterminantFast";
  usingCSF=false;
  NP = targetPtcl.getTotalNum();
  nels_up = targetPtcl.last(0)-targetPtcl.first(0);
  nels_dn = targetPtcl.last(1)-targetPtcl.first(1);
  FirstIndex_up=targetPtcl.first(0);
  FirstIndex_dn=targetPtcl.first(1);
  Dets.resize(2);
  Dets[0]=up;
  Dets[1]=dn;
  myG.resize(NP);
  myL.resize(NP);
  myG_temp.resize(NP);
  myL_temp.resize(NP);
  DetID.resize(NP);
  for(int i=0; i<targetPtcl.groups(); ++i)
    for(int j=targetPtcl.first(i); j<targetPtcl.last(i); ++j)
      DetID[j]=i;
  usingBF=false;
  BFTrans=0;
}

OrbitalBasePtr MultiSlaterDeterminantFast::makeClone(ParticleSet& tqp) const
{
  MultiDiracDeterminantBase* up_clone = new MultiDiracDeterminantBase(*Dets[0]);
  MultiDiracDeterminantBase* dn_clone = new MultiDiracDeterminantBase(*Dets[1]);
  MultiSlaterDeterminantFast* clone = new MultiSlaterDeterminantFast(tqp,up_clone,dn_clone);
  if(usingBF)
  {
    BackflowTransformation *tr = BFTrans->makeClone(tqp);
    clone->setBF(tr);
  }
  clone->resetTargetParticleSet(tqp);
  clone->C2node_up=C2node_up;
  clone->C2node_dn=C2node_dn;
  clone->Optimizable=Optimizable;
  clone->C=C;
  clone->myVars=myVars;
  clone->usingCSF=usingCSF;
  clone->usingBF=usingBF;
  if (usingCSF)
  {
    clone->CSFcoeff=CSFcoeff;
    clone->CSFexpansion=CSFexpansion;
    clone->DetsPerCSF=DetsPerCSF;
  }
  return clone;
}

MultiSlaterDeterminantFast::~MultiSlaterDeterminantFast() { }

void MultiSlaterDeterminantFast::resetTargetParticleSet(ParticleSet& P)
{
  if(usingBF)
  {
    BFTrans->resetTargetParticleSet(P);
    for(int i=0; i<Dets.size(); i++)
      Dets[i]->resetTargetParticleSet(BFTrans->QP);
  }
  else
  {
    for(int i=0; i<Dets.size(); i++)
      Dets[i]->resetTargetParticleSet(P);
  }
}

//  void MultiSlaterDeterminantFast::resize(int n1, int n2)
//  {
//  }

void MultiSlaterDeterminantFast::testMSD(ParticleSet& P, int iat)
{
//     APP_ABORT("Testing disabled for safety");
  app_log() <<"Testing MSDFast. \n";
  int n = nels_up+nels_dn;
  ParticleSet::ParticleGradient_t G(n),G0(n);
  ParticleSet::ParticleLaplacian_t L(n),L0(n);
  ValueType log, log0;
//     log = msd->evaluate(P,G,L);
  log0 = evaluate(P,G0,L0);
  /*
       app_log() <<"Testing evaluate(P,G,L). \n";
       cout<<endl <<endl;
       cout<<"Psi: " <<log <<"   " <<log0 <<"   " <<log/log0 <<endl;

       for(int i=0; i<n; i++) {
         cout<<i  <<"\n"
             <<"  x: " <<G(i)[0]-G0(i)[0] <<"\n"
             <<"  y: " <<G(i)[1]-G0(i)[1] <<"\n"
             <<"  z: " <<G(i)[2]-G0(i)[2] <<"\n"
             <<"  d2: " <<L(i)-L0(i) <<"\n"
             <<endl;
       }
       cout<<endl <<endl;
       APP_ABORT("end of test 1");
  */
  Walker_t::Buffer_t wbuffer;
  wbuffer.clear();
  log=registerData(P,wbuffer);
//     log = msd->evaluate(P,G,L);
  log0 = evaluate(P,G0,L0);
  PosType dr;
  dr[0] = 0.1;
  dr[1]=0.05;
  dr[2] = -0.01;
  PosType newpos(P.makeMove(iat,dr));
  app_log() <<"Testing ratio(P,dG,dL). \n";
  G=0;
  G0=0;
  L=0;
  L0=0;
//     log = msd->ratio(P,iat,G,L);
  log0 = ratio(P,iat,G0,L0);
  cout<<"Psi: " <<log <<"   " <<log0 <<"   " <<log/log0 <<endl;
  for(int i=0; i<n; i++)
  {
    cout<<i  <<"\n"
        <<"  x: " <<G(i)[0]-G0(i)[0] <<"  " <<G(i)[0]   <<"\n"
        <<"  y: " <<G(i)[1]-G0(i)[1] <<"  " <<G(i)[1] <<"\n"
        <<"  z: " <<G(i)[2]-G0(i)[2] <<"  " <<G(i)[2] <<"\n"
        <<"  d2: " <<L(i)-L0(i) <<"  " <<L(i) <<"\n"
        <<endl;
  }
  cout<<endl <<endl;
  APP_ABORT("After MultiSlaterDeterminantFast::testMSD()");
}

void MultiSlaterDeterminantFast::updateCoeff(RealType RminusRo){
  // update determinant coeffients with ion position

  // !!! hard-code coefficient interpolation
  RealType myslope[]={0.0,0.0218096391275,-0.0378741871324,0.00747063597266,-0.0220406660774,0.00814527976107,0.00297555271487,-0.0094900120758,-0.00286604451262,0.0074332080356,-0.00618287485993,-0.00313494898418,-0.00280968410336,0.00355925717679,-0.0124988022439,0.000401143471331,0.00582143071667,0.00420290402769,0.00770663123663,0.00742479106193,-0.00274438463795,-0.00659058238328,-0.0276729667496,0.00253319817279,-0.0174614947479,-0.000979174876028,0.00177107887363,0.00299356601117,0.00129826155063,-0.000689043006777,-0.000782787205843,-0.0047610559633,0.0384059448857,0.0300825382344,0.00474640761013,0.0029869069114,-0.00148940278933,0.0120281598306,0.00465209688889,-0.00239137871592,0.00037481461138,0.0063058823534,0.0021479964033,0.00446867513243,-0.00352752685401,-0.00301857722509,0.00656499341187,0.00503819884488,0.00238792410529,-0.00621211687043,-0.00149400902011,0.0100963637667,0.0011146897098,0.00106411200776,0.001173011304,-0.000566821934326,0.000362504697669,0.000845388339179,-0.000513568878508,-0.00259939219339,0.00183822444795,0.00202882796858,-0.00226877940154,-0.0047320125759,0.00616615839178,-0.00375340354003,-0.00120291165324,0.00311514936065,-0.00500374884648,0.000335070246421,2.66192619789e-05,-0.00101214728986,-0.00404456842582,-0.000409966027593,0.00648835485925,0.00480921108981,-0.00323665014532,0.00464929418836,0.0014457821345,-0.000455022781533,-0.0591512872588,-0.00146762141754,0.00272177009066,0.00225239813489,3.37333337486e-06,-0.000453105812406,0.00635401312206,-0.00431126311137,0.00269508061332,0.0643854508635,-0.0332546902141,-0.000630634707673,0.00318144383758,0.000624258256632,0.00118973622114,0.0293423962527,-0.000806269849257,-0.00476794235105,-0.00190158825229,0.00235375817314,0.000892856746665,
0.00696481640017,0.00388915280572,0.0015737090807,-0.00413279194979,-0.000265604822404,0.00183598749403,0.0031036531438,-0.00156556386545,-0.00356005804958,0.00313264885276,0.000340666848462,0.000494743168458,-0.00318846183375,-0.00100426463507,-0.00397994700263,0.000657791557924,0.00335990161602,0.0116282956766,0.0156434263497,-0.0013351481066,0.00156314787004,-0.0005148722791,-0.00259155774829,0.000819023927611,0.00047104330703,0.00703169598475,0.0031843994207,0.000857479422186,-0.000968222934621,0.000993682367858,0.000474274274649,-0.000115899296838,0.00240850856775,-0.00041633044761,-0.000157744289417,-0.00161022056567,0.000712731008433,0.000455048606981,0.00647235391566,0.00330877490915,0.00160199789689,0.000112704773963,0.000266270468726,8.35654895547e-05,-0.117177065974,-0.00638632799748,-0.00157715068593,0.00377748522089,-0.00127198888048,-0.00395471131355,0.00624376613127,0.00322388684987,0.00365202865326,-0.0024086755542,0.00232825761438,0.000862244963956,0.00472066173578,0.00358441341261,0.00110692069949,-0.000386322664535,-0.00282983756259,-0.000859238212795,-0.00121989864921,0.00184629766925,0.00133852422732,-0.00109608489792,0.0324387935614,0.00147346674581,-0.0136670111615,-0.0015806107544,0.00418146366659,-0.00147179224872,-0.000995445453945,0.0054479462094,-0.0023338808989,0.00231244934329,-0.0094286159202,-0.0011364079443,-0.00271944512101,-0.00266401728042,-0.00148137161641,-0.00133659076733,0.000744394825679,0.00299957982409,-0.000100561053089,0.00182347687351,0.00217636663444,0.000240240847503,-0.000232588730121,0.00406300742825,0.0058207871342,0.00163668446804,0.00229044797972,-0.00291233116968,-0.00190191598455,0.00146537844053,0.000987791558506,0.000599279308086,-0.00379558512893,0.00116190338063,
-0.020673767531,-0.00222963650515,0.00345555987723,0.0127524977083,0.000425951395892,0.000191723036731,-0.0001272090522,0.000113810666097,-0.00319244768526,0.00059943133339,-0.00116130136365,-0.00661134525715,0.00138463533517,0.00146881548003,0.00265345273707,0.00355091038824,-0.000702660938557,0.00159176329916,-0.000458520216548,0.000233323687361,0.000160637208498,-0.000210437703999,0.000893915695802,0.0034130230802,-0.0010844703441,-0.000756260234523,0.000140402951525,-0.00102871872753,-0.00127188456963,0.000733456087397,0.0138136408,-0.000293053789127,0.000880994220102,0.000141003107679,0.00412866599862,0.00143041507356,-0.000355284577678,0.000924358422607,0.000304931490083,-0.0191724655252,-0.00445424823382,0.000877638558983,-0.0016232134147,0.000519936289476,-0.00119285902477,0.000353687973719,0.00134919343205,-0.00119354757461,-0.000181867652225,0.00277840455946,-0.00106923015389,-0.00495955557287,0.00297619662149,-0.000486569970224,0.0021027901366,0.00101061735245,0.0115419780622,0.00156681060597,0.000140247863239,-0.000876107789002,-0.00133980414525,-0.00228040331659,-0.00466256789921,0.00117946445404,-0.000899957525418,-0.00044487732023,-0.000140288676094,0.00188404209767,0.00270038881813,-0.00155010856293,-0.00369929579953,0.00100482353113,0.00106991035992,0.000513465718358,-0.000210850898692,-0.000524901159885,-0.000822775845251,0.00199686051464,0.00355266248399,0.05523490647,-0.000643662715445,0.00060723642234,-0.00247464062037,0.00443171410395,0.00220812244357,6.52374818941e-05,-0.00114878137231,9.24315234629e-05,0.000312063759241,3.0022765035e-06,0.000681866997876,0.00118289530089,-0.0011021653285,0.00307104062517,0.000301116695791,-0.00144438929141,0.00181494056995,0.00509936080858,0.000300904127893,0.0089465334226,
-0.000838806182707,-0.0025704990024,-0.00314076124139,-0.000911352932658,0.000637216913498,0.00578350741687,-0.000923642725445,-0.000467057120373,0.00241793440158,-0.00199576379588,-0.00141507020299,-0.000336792540535,5.73458589795e-05,-0.00214879654656,-0.00162968537339,0.00110996132,-0.000333518223573,0.000937829099,0.00214154185704,-0.00149260925123,-0.000505628525381,-0.000788556562888,0.0015927000129,-0.000477687193664,-0.0026920212896,-0.000304135367622,0.00203711973671,-2.93712384798e-05,0.00200664556031,-0.0099091796743,0.000233701082893,0.00112588548776,-0.000602562615521,-0.00122237963342,-0.00113973540878,-0.00060905646512,-6.57427318655e-05,-0.00024250809151,0.00138568495712,-0.00225679137549,-0.000295705091155,-0.00165004134906,0.000224405551071,0.0012682277435,-0.00135582745077,-0.000238572937366,3.59552596575e-05,-0.000152563330553,-0.00252952267492,0.00126734338599,-0.00289928636478,0.000592294969709,-0.00358014048341,-0.000316928493786,-0.00419593596466,-0.00118002313565,0.0033420259088,0.00374323899508,4.25256571718e-05,0.000323723933586,-0.00188149097535,-0.000584197417154,0.00250701720068,0.00855573061408,0.000283345433675,0.000799245173164,-0.000288426107487,0.00612255846658,0.000641953453779,-0.00268712979766,-0.000216362643338,0.000330576998998,0.00181749263137,0.000637733991097,-0.00621105924318,-1.15509857281e-05,0.00011445848878,0.0010502702835,-0.000180883426826,-0.000465038158336,0.000320572279007,0.000104482087933,-0.00231481867889,0.00269395939303,-0.00125068360419,-0.0013661225944,-0.000512800531921,-0.000434518422315,-0.000808970540382,0.00157003542295,0.000136994382972,0.000552839259513,-0.000464908563267,0.0008416211511,-0.000120401048875,-0.00331951278066,-0.00364788231469,0.0017017726686,-0.000587121801335,0.00155506514018,
-0.000683351276939,-0.00070439847867,0.000926779648186,0.000728514864454,-0.00393556502028,-0.00123130245034,0.000471709789254,0.000502317763674,-0.00237768584692,-0.00269090549038,-0.00022014552165,-0.00180315571246,-0.00255871400317,0.000317683285127,6.13503117346e-05,0.000748125875253,0.000992929686542,0.0005106059906,-0.00348990256639,-0.000201707723829,-0.00326940401432,-0.00549229443093,-0.00144243973837,-0.000706820246354,0.00392292463043,4.38961011825e-05,0.000683950334746,-0.000683996795471,0.00123662103289,-0.000611159061186,-0.00159195591916,0.00103084692146,-0.000341308876013,-0.000770127308374,0.0013810956191,-0.000356298731898,6.79553670692e-05,-0.0189513098146,-0.00042827910442,0.00120895850251,-0.00045219420787,0.00240420173296,0.00168212797148,-0.00371581003859,-0.00298372229702,-0.00309391046139,0.00053121878722,-0.000929712761,-0.000878456356558,-0.00312831904735,0.000715938652482,0.001048148779,0.00237996520549,-0.000282217252348,-0.00032188988333,-0.00205096948504,0.000650498198414,-0.00109909375751,-0.000274243954517,-0.00171744523293,0.00113350980501,0.00154622697328,0.000952074090662,-0.00352835428441,8.7166418822e-05,0.000534036876042,-0.000344448470233,-3.89325075245e-05,0.000299688721254,-0.00333827937803,-0.000354428009482,0.000412644771071,0.00120544067666,-0.000843582958732,-3.87454674433e-05,-0.000317686714578,-0.00119302416048,0.000960806841102,0.000678512391219,0.00301280625501,0.00252050071959,-2.57584848653e-05,-0.0011775585926,-0.000445927171661,-0.00118229839752,-0.000818601787323,-8.91023340628e-05,0.00115825577993,0.000944032908161,0.000188852228971,-0.00106963369651,0.00116973842587,-0.00560429249935,-0.000171658292981,-0.00298640624263,0.00340623432654,-0.0030284865483,-0.000384401906101,-0.000944622910206,0.000300737669011,
-0.00203746743701,0.00100616749477,6.91215415737e-05,-0.000751656743163,-0.000578843428782,-0.00185343707792,0.00139513769813,0.0017133480694,-0.000330057643142,0.00111714890674,-0.000649800530159,0.000306309966273,-0.000211046299501,0.000854263579804,-0.0018483180063,-0.00100984441235,-0.00036661282292,-0.000584175230781,-0.0018701257947,-0.000891537736559,0.00020693761909,0.00114275437888,-0.00504472934491,-0.00212958818658,-0.000114171970078,0.00230029546931,0.00142516817679,-0.00214238479885,-0.00166640462679,-0.000592685533027,-0.000352103562327,9.61851062575e-07,-0.00065788634715,-0.00156215184861,-0.000661301048025,-0.000156003975012,-0.000189977458846,-2.37141507026e-05,0.00054415029989,0.000364673184037,0.000314967486584,0.000706138164778,0.00119000232952,-0.00057100565657,-0.000179631105239,-0.000422651098726,-0.000542107378352,3.2218955488e-06,0.00256214828932,0.00607284345109,0.0031813380679,-0.00325870606823,0.000591763826606,0.00346955762637,0.00613167699065,0.000160813540319,-0.00288808399781,-0.00250458989129,0.000780777825165,0.00109341256652,0.000524736347602,-0.0015927946173,-8.45789336597e-05,-0.000225258469994,0.000406708437043,0.00175581865511,-0.000563589131619,-0.000723085503648,0.000403987522023,-0.000160977501438,-0.000507180830274,-0.000153838730301,-0.00128825225915,1.5083781966e-05,0.00113135445861,-8.37695559466e-05,0.00189717656079,0.000796826608704,0.00193646548589,0.00129699989568,-0.00117554564135,-0.000904053282265,0.00346645670853,-0.00243325420945,0.00624030830929,0.00143119953141,-0.000574566984017,-0.000646968177092,-6.22563892836e-05,-0.00245409308434,-9.9482241255e-05,0.00198644791795,-0.00258105267506,0.000245893410159,-0.00295007205742,-0.00026577216384,-0.000425799245001,0.00258278491265,0.000528610530513,-0.000254693025953,
0.000726311314023,-0.00198549824969,-0.00197482897312,-0.00172526965099,-0.000327117721969,-0.000137933665584,0.00132013769053,0.00205350708077,0.00207574273494,8.33168748934e-05,-7.02800128209e-05,0.000418204924135,-0.000175186999346,-0.00088995522095,-0.000313561135115,0.00456762179889,-0.000884362992603,-0.00118931840257,-0.000758101901332,-0.000369148838312,0.00231636793009,-0.00258733586162,0.000644341175213,-0.00116472484446,0.000461201339685,0.000435667628387,-0.000649602124004,0.000838915407738,-8.80444451028e-05,0.000361480326686,4.06801425663e-05,0.00142578788806,-0.000819584502735,0.000442350642499,0.00186273919182,-0.000120820452693,-0.000937781081947,-0.000634471289347,0.000106245544616,-0.00029133146872,0.00079721501599,-0.000493284242012,-0.00228397416582,0.000260538156483,0.000501285444528,-0.00329782708582,-0.00299838881685,0.000922449975306,0.00186440370914,-0.00142111365817,-0.000145938585199,0.00053893284942,0.00043679859388,0.000646658332086,0.0010011328902,0.000322571124487,-4.27453301959e-05,9.78714854135e-05,0.0016903559333,0.00250977692622,-0.000858895201499,0.00207975726329,-0.000487188147451,-0.00160387845051,-0.000279251548446,0.000598060406857,0.0024650333246,0.000361232736662,-0.000110263008291,-0.000944536935486,0.000866466593427,0.00128902524758,-0.00423542885448,0.00130571601032,0.00106988695223,-0.000620493084631,0.000718679162749,-0.00157328662873,0.000250676215091,0.00158305961294,-2.32709688415e-05,0.00185393822035,-0.000590817549002,-0.000112907508631,0.00140870994984,0.00119227348545,0.00144869019251,-0.000416521855497,0.00259637811633,-0.0007655301284,0.00125367889902,-0.00075593179711,-0.000587977261048,-0.000764856280324,-0.000979583936083,-0.000175576631326,-0.00911665144391,0.000515102482746,-0.000362656008322,0.000182767261646,
0.000343793564323,0.000493105021157,0.000737967276204,0.00069079555198,-0.00132419063595,-0.000988785565763,-0.003297463551,-0.00249254995461,0.00058179254307,-0.00261733838647,0.00304010837546,0.000102554902749,-0.00115039203595,-0.000308467555241,-0.00692295838432,-0.00259645922451,0.00101017568572,-0.000375317456567,0.000145134988305,0.000937172814845,-0.000969840027709,-0.00116226533765,0.00112479692384,0.0011647063584,0.00429333073056,-0.000745499698323,0.00265006593619,-0.000700657437421,-0.00131942099028,-0.00206128654628,-0.000530054809101,-0.000119213203959,0.00185839596359,0.00274565650978,0.00234279808174,8.01757191794e-05,0.000273786345186,0.000494105259894,0.00026855893596,0.00116828605018,0.000126878320017,1.31175579283e-05,0.000733397249318,0.00186925156568,6.77608948846e-05,-0.000570793430468,-0.000692792323554,-0.000445546784841,-0.00174415117725,-0.00189053249301,-0.00412493667899,-0.00118665747085,0.000648565908614,0.000142070640919,0.017657766902,-0.000476316558038,-0.000654323759817,-0.000997517664361,-0.000146498501302,-0.000330758852088,-0.00132795281616,0.000557063933857,-0.000137034610371,-0.00132466671505,0.00354842906916,0.000231135550865,-0.00101335990201,0.00108214005062,-0.000811989587007,-0.000246428266717,-3.67057259669e-05,-0.00100819803072,0.00862730660119,0.0010069021433,-3.20853310809e-07,-0.0022957959604,0.00249424763844,-0.000230664194435,-0.000356663106194,0.000646985213955,0.000253451452855,0.00133875839014,-0.00296886200907,-0.00376144189863,-0.00099900225103,0.00099442708963,2.05658166612e-05,0.00218123633858,0.00121714212554,0.00122358638398,0.000836259538947,0.00014181012156,0.000835317016047,-0.0010862768748,0.000530681259776,-0.000949538092804,0.000707935381362,-0.00166376815401,1.63125141484e-06,0.00230890277666,
-0.000200917385276,-0.00101317945006,0.00022844886497,0.000100132614193,-0.00128010111446,-0.00321867836064,0.00145672966329,-0.00166790142041,-0.000370035645369,0.000322837225589,-0.002437598383,0.000410888036154,-0.0017148659874,-0.00143123875933,-0.00198017641043,3.99529030014e-05,0.000186748174385,-0.000342962723808,-0.00354151798455,-0.00368506537179,0.000114147390214,0.000300925159538,-0.00043897207594,4.0900119558e-05,0.00480344742807,0.0008053152367,-0.000144580609865,-0.000152651409241,-0.000575305945882,-0.00141074005558,-0.000530266539429,-0.000506154125549,0.00169244758823,-0.00230617179061,0.00048220463283,-0.00078182840462,0.000386030544314,-0.00141244035693,-0.00134196436029,-0.00236610201022,-0.00232834775193,0.00299137713367,0.000235312679409,0.000493851947807,-7.2013520507e-05,0.00145405510187,-0.00192560944903,6.62227628239e-05,0.000908842506766,8.94328165991e-05,-0.000934739419439,-0.000786894105478,-2.88478454604e-05,-0.0025284790447,-0.00146127566402,0.00151484787403,-0.000484460839962,-0.00207814459003,-0.00228523583318,0.00402260771747,0.00469969438489,-0.00077180785331,0.00366987539008,0.000153264908125,0.00204476082562,-0.00142914386383,0.000542913287065,-0.000469580649079,-0.000739152795287,0.00133488376412,3.3005075492e-05,0.000993428170231,-0.00548818755903,-0.000752463930675,0.000303088190308,-0.00103077332351,0.00107024193053,0.00161532924187,0.00176411101117,-0.00257716784674,0.000215592407634,0.00231981273064,0.000906240118266,-0.00113458295469,0.00114700126126,0.0002666790272,-0.00109174951511,-0.000729509942995,-0.000819218112409,0.00214104020355,-0.000145768910107,-0.000135148235435,-0.000595142777021,-0.00576807985989,0.0023891348548,0.00318126549301,0.000208502909894,-0.00138889619,-0.00087909481685,-0.000647632205847,
-3.74477010858e-05,-0.00117703657276,0.00149323000738,0.00030219545096,0.00133589605679,0.00215450580346,2.6472871792e-05,0.000800562940622,0.000332276166062,0.000323965200952,-0.00035222445926,-0.000483010432544,-2.21288431552e-05,0.000536092927328,0.00164234653168,-0.00464428707364,-0.00099029217647,0.00161862202707,0.000371944516365,-0.00102785949479,-0.000264157239992,-0.00262554190324,0.000586973849537,-0.00177140178526,2.54945826684e-05,0.000851554042727,0.0028261257328,-0.000466440905062,0.000518193039717,0.00124973987966,0.00077127702729,0.000469005327693,-0.0098741918831,0.000330930511442,0.00431483786271,0.000133475215488,0.00112253313081,-0.000334105456383,-0.00112983094793,0.0021150005623,0.000801172398441,0.000370095483379,0.00110188928624,-0.000261239849488,0.000189970080134,-0.00318060602963,0.00295249954239,0.000211674727458,-0.00272510402904,-0.000914721167903,0.00254495086501,0.00182762278277,-0.00104034313395,-0.000194127154893,-0.0016964415508,-0.00133796965998,-0.000504174901315,-0.000360570142931,0.00253688010013,1.40103303348e-05,0.000136279773256,-0.00268103675894,0.000729510756164,-0.000333099834834,0.00121844706789,-0.00109846116826,0.00827665744838,0.00177304001612,-0.000672590473992,-0.000431625189587,-0.000189029767936,-0.00185698489101,-0.00123422905261,0.000319414220451,0.00426976537558,-0.00015516062618,0.000315605829144,-0.0010010977634,0.00132602436734,-0.00100106074219,-0.000762442525189,0.00221816829373,0.00218169990278,0.000510204481801,-0.000475555982997,0.000820570446723,0.00134545482211,0.00500550424313,0.000198089237008,0.00064440106734,0.00114858782286,0.00201646949606,-0.000156791065355,-0.000434906689227,-0.00114151779417,-0.000766926451065,-0.00238158031603,-0.000355683824402,-0.00015071415084,-0.00131541333431,
0.000980587884874,-0.00217571648676,0.00381523922926,0.00093402719722,0.000678551330693,0.0021837142892,-0.00145840750278,0.00353298785563,-0.000585101490376,-0.000669551705344,0.00290585990118,-0.00050064136709,-0.00222213135286,-0.00158062894519,-0.00302412923117,-0.000757596443038,0.00308995077789,-0.000825338228409,-0.00125543545328,0.00205749078826,-0.000635909107845,-0.00161261823481,0.000566092966597,0.00068901833767,-0.000770951348755,-0.000151443539598,0.0027523863634,4.80880755364e-05,-0.000915560805744,-0.0033719722719,0.00123556464638,0.000916291252704,-0.00870777694668,0.000787057670453,-0.000532837603707,0.000106014587708,-0.000802700492252,0.000492143266022,-0.000314726365947,0.000415358444916,-0.000448512323105,0.00276002739222,-0.0022561852679,-8.59259796204e-06,-7.2632770505e-05,0.000170190878431,0.000360475310273,0.0008621883557,-0.000499767887959,0.000590199607244,0.00101052194711,-0.00159462203814,-0.00130123449157,0.000154430208443,-0.000722958740973,0.000780746731343,0.000447999917948,-0.000409624182044,-0.000476292845032,-3.5881618744e-05,0.00100456080315,-0.00130837877445,0.000602119273929,0.00142225705006,-0.00217204451588,-0.00281847943857,0.00265520117085,-0.000383562610672,-0.000744038067524,0.000196775303926,-0.000756270481588,8.41179498733e-05,0.00157901947934,9.20560488891e-05,0.000460572559678,1.6352308617e-05,0.00170839245261,-0.000392601928195,-0.00134526385422,-5.46633607401e-05,-0.00113838695796,0.00161363102895,-4.36141081683e-05,-0.000916317199847,-0.000183178335103,0.000543636688603,0.000759759061171,5.85977821133e-05,-0.00119831414601,0.00137706170734,-0.000395237993673,-0.000331266245158,-0.000614070981929,0.00169229334524,-0.00125734948997,0.000960137817706,-0.000715764509955,-0.000901419205431,-0.00032967582091,0.000227806037744,
-0.00015685977335,0.000343267545086,-0.00808501977715,-0.000547449233356,-1.73065419347e-05,0.00190517096789,-0.00769784170671,0.000455134738646,0.000282630363074,-0.000279964459719,-0.000536365789781,-0.00206931296113,0.000476226545964,-0.000262777097678,0.00019252894904,0.0026599238166,0.000638791521619,-0.000143997953023,5.60384096594e-05,-0.00191470097498,0.00130168878479,-9.59051500058e-05,-0.000870213935447,-0.000585293283477,0.00325821556187,0.000400304148858,-0.00108484833711,-0.000972968318678,0.00018590102,-0.000181974235563,0.00109730132026,-0.00049681243139,0.00254338660857,-0.00252411179811,0.000830122166541,-0.00395157352246,-0.000145562888846,0.00472872413831,-0.000368693678845,-0.00132532436183,0.00148512855605,-0.00673784342899,-0.000959313810964,0.000465769238929,0.00113373924119,-0.000311161547889,0.00141672453179,0.00269256595427,0.0003266641615,-0.00311749207023,-0.000204852764258,-0.00241774855156,-3.77945902454e-05,-0.000323610003593,0.00250101331708,0.00158925436259,0.000660297444347,0.000229843096442,-0.000162428009198,8.69393835522e-05,-0.000393612562571,-0.0014725324061,0.00104683831022,-4.44124813467e-05,0.00149863282724,0.00298451864748,0.00051984856959,0.000463916048587,0.000347130393287,-0.00163886189445,0.000100007415293,0.0011436728449,-0.000186797642163,-0.00110252907457,7.11937835669e-05,-0.000390146931262,-0.000389104781366,-0.00166069069651,-0.000776865868938,0.000646021842928,-0.000403431128276,-0.000474034797699,0.000452558785068,-0.00399999922927,0.000227320303914,0.000334941944179,-0.000762878922409,-0.000147417207492,0.000122314300198,0.00092132841904,0.000250163123044,2.16538668618e-05,0.000317394464275,0.00139709927161,-0.0028381687538,0.00046815982303,0.000985887132221,-0.000402881967168,-0.00189734057295,-0.0015181674841,
0.000194221373156,0.000979684948779,-0.000961229787286,-0.00569662691659,0.00073350003719,-0.000780047151848,-0.00384866898269,0.000659181708194,-0.00047552385003,-0.000607639641745,-0.00447145521928,0.00150725579644,0.000566984508754,0.000439152765528,0.000983577140245,-0.00134701202481,0.000748580444756,0.00098186849458,0.000362278520771,-0.000856309871778,-0.000493346184635,0.000177468774416,-0.00192381250486,0.000533979464774,-0.00153721231632,5.36994651738e-05,-9.96568849336e-05,0.00195854240971,-0.000681232123167,-0.000616417683045,-0.000593444192625,9.73331766025e-05,0.00078676941774,-0.000166251780852,0.000270627637769,-0.000305232443179,-0.000542606601306,0.000551681799123,-0.000556346376878,-0.000845232369508,-0.000771864376555,0.000421834195939,0.00111752108264,0.00115276270234,-0.00129184231672,-0.000366178412238,-9.08280950531e-05,-6.19835960181e-06,-0.0021493733405,-0.00154203201142,0.000343174392564,0.000338396268693,-0.000533307762512,0.000791604612568,-0.000688346889306,0.00103350482386,-0.00114423921275,-0.000974200209934,0.00226460031948,-0.000556252425023,0.000125919304672,-0.000659014174258,0.00222458792636,0.000530694018229,0.000468040856474,-0.000107514214099,-0.000492339475138,-5.49205812814e-05,-0.000210122589145,-0.00556927579101,0.00183288332849,0.000815570710096,-0.00148614501309,-0.00159489960345,-0.00099027643701,-2.5846770674e-05,0.000686227917133,-0.000519120525632,0.000405113635059,-0.000492473498291,0.000435981556648,0.000804007781415,-0.000207955828362,-0.000647025383582,-0.000273353939527,-0.00117119498416,-0.00277779973562,0.000873021290782,-0.000764873191468,-0.0014010015879,-0.00017571676492,-0.000365767161531,-0.000818414449752,0.00152014027188,-0.000297584089893,0.00202082107117,-0.000218858924301,0.00162422586148,5.48131182996e-05,0.00113409402506,
-0.000231573613998,-0.000371160755072,0.000559111275958,-0.000404440386624,-0.000602710792503,-0.000289430087693,0.000858372121929,0.00130271482021,-0.000272279868291,0.00062017376369,0.00103652383436,-0.00200442528108,0.00254177660168,0.000111592058573,-8.17242897533e-05,0.0070833749896,-0.0012186805541,-0.000193135929727,0.000626953791009,-0.000212933718666,0.00113746117512,0.000328748422294,0.00303332937866,6.26566932984e-05,-0.00140114753428,-0.000296166420059,0.000751533409122,-0.000760250931674,2.89488997629e-05,-0.00135839275102,0.000854428672598,-0.000818506784622,0.000682057986858,0.0052665871447,0.000935516541451,0.000978029843449,-0.00125837585961,-0.00040791564922,4.77607701367e-05,0.00080213907312,-0.00120774198325,-0.000532583178014,4.89584743277e-05,-0.00015574845536,0.000698550731325,0.000953786406413,-0.000426123077976,0.00100875285306,0.000207774519575,-0.000705687171807,-0.0066226351415,0.00184295233375,0.000206289842153,-0.000486231235285,0.00168412302619,0.000703957866705,0.00273544601928,0.000106360474629,-0.00131427245283,-0.00222145872529,0.000311849023726,0.000265852033018,-0.000624919529689,0.000915642696813,-0.00137997717962,-1.8723326596e-05,-0.000937704010081,-0.00104669781738,-1.57093230584e-05,-0.000162043887238,0.000268773754716,-0.000784669569123,-0.000185641417619,-0.000463296350416,0.000831625928393,0.000499334254394,-0.000979243519485,0.00061267910944,-0.00131422122073,0.00289078927972,0.000106898992484,-0.000436611703478,0.00130085253538,0.00130910686578,0.00117306544975,-0.000576919136104,0.000305784817536,-0.000101253282599,-0.000278505818168,0.00908355439312,0.000857153230465,0.000692091922791,0.000406745525364,-0.00072164229323,-0.00184589610757,-0.000304986767573,-0.00469852656395,-0.000525790525334,-0.00020462026689,0.002172130933,
-0.0341957679892,-0.000831607707783,0.000490686397582,0.000248256655088,-0.000247815475228,-0.000672759001487,0.00344297366215,-0.00171382291633,-0.000872032749724,0.000288204025397,0.00135449334653,0.00175544280046,0.0018638886198,-0.00227166258354,0.00019120716796};
  vector<RealType> slope(myslope,myslope+sizeof(myslope)/sizeof(RealType));

  // C contains current coefficients
  // CSFcoeff initialized with original coefficients in MultiSlaterDeterminantFast constructor
    // - this should work for restart since original C are always read from input ptcl.xml
  vector<RealType>::iterator it(C.begin()),last(C.end());
  vector<RealType>::iterator original_it(originalC.begin()),original_last(originalC.end());
  vector<RealType>::iterator slope_it(slope.begin()),slope_last(slope.end());
  while(it != last){ // linear interpolation
    // Ci(R)=dCi/dR*(R-Ro)+Ci(Ro)
    (*it)=(*slope_it)*RminusRo+(*original_it); 
    it++; slope_it++; original_it++;
  }
}
OrbitalBase::ValueType MultiSlaterDeterminantFast::evaluate(ParticleSet& P
    , ParticleSet::ParticleGradient_t& G, ParticleSet::ParticleLaplacian_t& L)
{
  EvaluateTimer.start();
  //for(int i=0; i<Dets.size(); i++)
  //  Dets[i]->evaluateForWalkerMove(P);
  Dets[0]->evaluateForWalkerMove(P);
  Dets[1]->evaluateForWalkerMove(P);
  // can this change over time??? I don't know yet
  ValueVector_t& detValues_up = Dets[0]->detValues;
  ValueVector_t& detValues_dn = Dets[1]->detValues;
  GradMatrix_t& grads_up = Dets[0]->grads;
  GradMatrix_t& grads_dn = Dets[1]->grads;
  ValueMatrix_t& lapls_up = Dets[0]->lapls;
  ValueMatrix_t& lapls_dn = Dets[1]->lapls;
  int N1 = Dets[0]->FirstIndex;
  int N2 = Dets[1]->FirstIndex;
  int NP1 = Dets[0]->NumPtcls;
  int NP2 = Dets[1]->NumPtcls;
  psiCurrent=0.0;
  myG=0.0;
  myL=0.0;
  vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
  vector<RealType>::iterator it(C.begin()),last(C.end());
  while(it != last)
  {
    psiCurrent += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
    for(int k=0,n=N1; k<NP1; k++,n++)
    {
      myG(n) += (*it)*grads_up(*upC,k)*detValues_dn[*dnC];
      myL(n) += (*it)*lapls_up(*upC,k)*detValues_dn[*dnC];
    }
    for(int k=0,n=N2; k<NP2; k++,n++)
    {
      myG(n) += (*it)*grads_dn(*dnC,k)*detValues_up[*upC];
      myL(n) += (*it)*lapls_dn(*dnC,k)*detValues_up[*upC];
    }
    it++;
    upC++;
    dnC++;
  }
  ValueType psiinv = 1.0/psiCurrent;
  myG *= psiinv;
  myL *= psiinv;
  G += myG;
  for(int i=0; i<L.size(); i++)
    L(i) += myL[i] - dot(myG[i],myG[i]);
  EvaluateTimer.stop();
  return psiCurrent;
}

OrbitalBase::RealType MultiSlaterDeterminantFast::evaluateLog(ParticleSet& P
    , ParticleSet::ParticleGradient_t& G, ParticleSet::ParticleLaplacian_t& L)
{
  ValueType psi = evaluate(P,G,L);
  return LogValue = evaluateLogAndPhase(psi,PhaseValue);
}

OrbitalBase::RealType MultiSlaterDeterminantFast::evaluateLog(ParticleSet& P,
    ParticleSet::ParticleGradient_t& G,
    ParticleSet::ParticleLaplacian_t& L,
    PooledData<RealType>& buf,
    bool fillBuffer )
{
  if(fillBuffer)
  {
    Dets[0]->evaluateForWalkerMove(P);
    Dets[0]->copyToDerivativeBuffer(P,buf);
    Dets[1]->evaluateForWalkerMove(P);
    Dets[1]->copyToDerivativeBuffer(P,buf);
  }
  else
  {
    Dets[0]->copyFromDerivativeBuffer(P,buf);
    Dets[1]->copyFromDerivativeBuffer(P,buf);
  }
  // can this change over time??? I don't know yet
  ValueVector_t& detValues_up = Dets[0]->detValues;
  ValueVector_t& detValues_dn = Dets[1]->detValues;
  GradMatrix_t& grads_up = Dets[0]->grads;
  GradMatrix_t& grads_dn = Dets[1]->grads;
  ValueMatrix_t& lapls_up = Dets[0]->lapls;
  ValueMatrix_t& lapls_dn = Dets[1]->lapls;
  int N1 = Dets[0]->FirstIndex;
  int N2 = Dets[1]->FirstIndex;
  int NP1 = Dets[0]->NumPtcls;
  int NP2 = Dets[1]->NumPtcls;
  psiCurrent=0.0;
  myG=0.0;
  myL=0.0;
  vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
  vector<RealType>::iterator it(C.begin()),last(C.end());
  while(it != last)
  {
    psiCurrent += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
    for(int k=0,n=N1; k<NP1; k++,n++)
    {
      myG(n) += (*it)*grads_up(*upC,k)*detValues_dn[*dnC];
      myL(n) += (*it)*lapls_up(*upC,k)*detValues_dn[*dnC];
    }
    for(int k=0,n=N2; k<NP2; k++,n++)
    {
      myG(n) += (*it)*grads_dn(*dnC,k)*detValues_up[*upC];
      myL(n) += (*it)*lapls_dn(*dnC,k)*detValues_up[*upC];
    }
    it++;
    upC++;
    dnC++;
  }
  ValueType psiinv = 1.0/psiCurrent;
  myG *= psiinv;
  myL *= psiinv;
  G += myG;
  for(int i=0; i<L.size(); i++)
    L(i) += myL[i] - dot(myG[i],myG[i]);
  return evaluateLogAndPhase(psiCurrent,PhaseValue);
}


OrbitalBase::GradType MultiSlaterDeterminantFast::evalGrad(ParticleSet& P, int iat)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: evalGrad not implemented. \n");
  }
  GradType grad_iat;
  if(DetID[iat] == 0)
  {
    Dets[0]->evaluateGrads(P,iat);
    ValueVector_t& detValues_up = Dets[0]->detValues;
    ValueVector_t& detValues_dn = Dets[1]->detValues;
    GradMatrix_t& grads_up = Dets[0]->grads;
    int N1 = Dets[0]->FirstIndex;
    ValueType psi=0.0;
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    while(it != last)
    {
      psi += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
      grad_iat += (*it)*grads_up(*upC,iat-N1)*detValues_dn[*dnC];
      it++;
      upC++;
      dnC++;
    }
    grad_iat *= 1.0/psi;
    return grad_iat;
  }
  else
  {
    Dets[1]->evaluateGrads(P,iat);
    ValueType psi=0.0;
    ValueVector_t& detValues_up = Dets[0]->detValues;
    ValueVector_t& detValues_dn = Dets[1]->detValues;
    GradMatrix_t& grads_dn = Dets[1]->grads;
    int N2 = Dets[1]->FirstIndex;
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    while(it != last)
    {
      psi += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
      grad_iat += (*it)*grads_dn(*dnC,iat-N2)*detValues_up[*upC];
      it++;
      upC++;
      dnC++;
    }
    grad_iat *= 1.0/psi;
    return grad_iat;
  }
}

OrbitalBase::ValueType MultiSlaterDeterminantFast::ratioGrad(ParticleSet& P
    , int iat, GradType& grad_iat)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: ratioGrad not implemented. \n");
  }
  UpdateMode=ORB_PBYP_PARTIAL;
  if(DetID[iat] == 0)
  {
    RatioGradTimer.start();
    Ratio1GradTimer.start();
    Dets[0]->evaluateDetsAndGradsForPtclMove(P,iat);
    Ratio1GradTimer.stop();
    ValueVector_t& detValues_up = Dets[0]->new_detValues;
    ValueVector_t& detValues_dn = Dets[1]->detValues;
    GradMatrix_t& grads_up = Dets[0]->new_grads;
    int N1 = Dets[0]->FirstIndex;
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    ValueType psiNew=0.0;
    GradType dummy;
    it=C.begin();
    last=C.end();
    while(it != last)
    {
      psiNew += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
      dummy += (*it)*grads_up(*upC,iat-N1)*detValues_dn[*dnC];
      it++;
      upC++;
      dnC++;
    }
    grad_iat+=dummy/psiNew;
    curRatio = psiNew/psiCurrent;
    RatioGradTimer.stop();
    return curRatio;
  }
  else
  {
    RatioGradTimer.start();
    Ratio1GradTimer.start();
    Dets[1]->evaluateDetsAndGradsForPtclMove(P,iat);
    Ratio1GradTimer.stop();
    ValueVector_t& detValues_up = Dets[0]->detValues;
    ValueVector_t& detValues_dn = Dets[1]->new_detValues;
    GradMatrix_t& grads_dn = Dets[1]->new_grads;
    int N2 = Dets[1]->FirstIndex;
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    ValueType psiNew=0.0;
    GradType dummy;
    while(it != last)
    {
      psiNew += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
      dummy += (*it)*grads_dn(*dnC,iat-N2)*detValues_up[*upC];
      it++;
      upC++;
      dnC++;
    }
    grad_iat+=dummy/psiNew;
    curRatio = psiNew/psiCurrent;
    RatioGradTimer.stop();
    return curRatio;
  }
}


// This routine need work, sloppy for now
OrbitalBase::ValueType  MultiSlaterDeterminantFast::ratio(ParticleSet& P, int iat
    , ParticleSet::ParticleGradient_t& dG,ParticleSet::ParticleLaplacian_t& dL)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: ratio(P,dG,dL) not implemented. \n");
  }
  UpdateMode=ORB_PBYP_ALL;
  if(DetID[iat] == 0)
  {
    RatioAllTimer.start();
    /*
          P.acceptMove(iat);
          Dets[0]->evaluateForWalkerMove(P);
          ValueVector_t& detValues_up = Dets[0]->detValues;
          ValueVector_t& detValues_dn = Dets[1]->detValues;
          GradMatrix_t& grads_up = Dets[0]->grads;
          GradMatrix_t& grads_dn = Dets[1]->grads;
          ValueMatrix_t& lapls_up = Dets[0]->lapls;
          ValueMatrix_t& lapls_dn = Dets[1]->lapls;
    */
//*
    Ratio1AllTimer.start();
    Dets[0]->evaluateAllForPtclMove(P,iat);
    Ratio1AllTimer.stop();
    ValueVector_t& detValues_up = Dets[0]->new_detValues;
    ValueVector_t& detValues_dn = Dets[1]->detValues;
    GradMatrix_t& grads_up = Dets[0]->new_grads;
    GradMatrix_t& grads_dn = Dets[1]->grads;
    ValueMatrix_t& lapls_up = Dets[0]->new_lapls;
    ValueMatrix_t& lapls_dn = Dets[1]->lapls;
//*/
    int N1 = Dets[0]->FirstIndex;
    int N2 = Dets[1]->FirstIndex;
    int NP1 = Dets[0]->NumPtcls;
    int NP2 = Dets[1]->NumPtcls;
    ValueType psiNew=0.0;
    // myG,myL should contain current grad and lapl
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    myG_temp=0.0;
    myL_temp=0.0;
    while(it != last)
    {
      psiNew += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
      for(int k=0,n=N1; k<NP1; k++,n++)
      {
        myG_temp(n) += (*it)*grads_up(*upC,k)*detValues_dn[*dnC];
        myL_temp(n) += (*it)*lapls_up(*upC,k)*detValues_dn[*dnC];
      }
      for(int k=0,n=N2; k<NP2; k++,n++)
      {
        myG_temp(n) += (*it)*grads_dn(*dnC,k)*detValues_up[*upC];
        myL_temp(n) += (*it)*lapls_dn(*dnC,k)*detValues_up[*upC];
      }
      it++;
      upC++;
      dnC++;
    }
    ValueType psiNinv=1.0/psiNew;
    myG_temp *= psiNinv;
    myL_temp *= psiNinv;
    dG += myG_temp-myG;
    for(int i=0; i<dL.size(); i++)
      dL(i) += myL_temp[i] - myL[i] - dot(myG_temp[i],myG_temp[i]) + dot(myG[i],myG[i]);
    curRatio = psiNew/psiCurrent;
    RatioAllTimer.stop();
    return curRatio;
  }
  else
  {
    RatioAllTimer.start();
    Ratio1AllTimer.start();
    Dets[1]->evaluateAllForPtclMove(P,iat);
    Ratio1AllTimer.stop();
    ValueVector_t& detValues_up = Dets[0]->detValues;
    ValueVector_t& detValues_dn = Dets[1]->new_detValues;
    GradMatrix_t& grads_up = Dets[0]->grads;
    GradMatrix_t& grads_dn = Dets[1]->new_grads;
    ValueMatrix_t& lapls_up = Dets[0]->lapls;
    ValueMatrix_t& lapls_dn = Dets[1]->new_lapls;
    int N1 = Dets[0]->FirstIndex;
    int N2 = Dets[1]->FirstIndex;
    int NP1 = Dets[0]->NumPtcls;
    int NP2 = Dets[1]->NumPtcls;
    ValueType psiNew=0.0;
    // myG,myL should contain current grad and lapl
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    myG_temp=0.0;
    myL_temp=0.0;
    while(it != last)
    {
      psiNew += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
      for(int k=0,n=N1; k<NP1; k++,n++)
      {
        myG_temp(n) += (*it)*grads_up(*upC,k)*detValues_dn[*dnC];
        myL_temp(n) += (*it)*lapls_up(*upC,k)*detValues_dn[*dnC];
      }
      for(int k=0,n=N2; k<NP2; k++,n++)
      {
        myG_temp(n) += (*it)*grads_dn(*dnC,k)*detValues_up[*upC];
        myL_temp(n) += (*it)*lapls_dn(*dnC,k)*detValues_up[*upC];
      }
      it++;
      upC++;
      dnC++;
    }
    ValueType psiNinv=1.0/psiNew;
    myG_temp *= psiNinv;
    myL_temp *= psiNinv;
    dG += myG_temp-myG;
    for(int i=0; i<dL.size(); i++)
      dL(i) += myL_temp[i] - myL[i] - dot(myG_temp[i],myG_temp[i]) + dot(myG[i],myG[i]);
    curRatio = psiNew/psiCurrent;
    RatioAllTimer.stop();
    return curRatio;
  }
}

// use ci_node for this routine only
OrbitalBase::ValueType MultiSlaterDeterminantFast::ratio(ParticleSet& P, int iat)
{
// debug
//    testMSD(P,iat);
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: ratio not implemented. \n");
  }
  UpdateMode=ORB_PBYP_RATIO;
  if(DetID[iat] == 0)
  {
    RatioTimer.start();
    Ratio1Timer.start();
    Dets[0]->evaluateDetsForPtclMove(P,iat);
    Ratio1Timer.stop();
    ValueVector_t& detValues_up = Dets[0]->new_detValues;
    ValueVector_t& detValues_dn = Dets[1]->detValues;
    ValueType psiNew=0.0;
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    while(it != last)
      psiNew += (*(it++))*detValues_up[*(upC++)]*detValues_dn[*(dnC++)];
    curRatio = psiNew/psiCurrent;
    RatioTimer.stop();
    return curRatio;
  }
  else
  {
    RatioTimer.start();
    Ratio1Timer.start();
    Dets[1]->evaluateDetsForPtclMove(P,iat);
    Ratio1Timer.stop();
    ValueVector_t& detValues_up = Dets[0]->detValues;
    ValueVector_t& detValues_dn = Dets[1]->new_detValues;
    ValueType psiNew=0.0;
    vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
    vector<RealType>::iterator it(C.begin()),last(C.end());
    while(it != last)
      psiNew += (*(it++))*detValues_up[*(upC++)]*detValues_dn[*(dnC++)];
    curRatio = psiNew/psiCurrent;
    RatioTimer.stop();
    return curRatio;
  }
}

void MultiSlaterDeterminantFast::acceptMove(ParticleSet& P, int iat)
{
// this should depend on the type of update, ratio / ratioGrad
// for now is incorrect fot ratio(P,iat,dG,dL) updates
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: acceptMove not implemented. \n");
  }
// update psiCurrent,myG_temp,myL_temp
  AccRejTimer.start();
  psiCurrent *= curRatio;
  curRatio=1.0;
  Dets[DetID[iat]]->acceptMove(P,iat);
  switch(UpdateMode)
  {
  case ORB_PBYP_ALL:
    // ratio(P,iat,dG,dL)
    myG = myG_temp;
    myL = myL_temp;
    break;
  default:
    break;
  }
  AccRejTimer.stop();
//    Dets[0]->evaluateForWalkerMove(P);
//    Dets[1]->evaluateForWalkerMove(P);
  // can this change over time??? I don't know yet
  /*
      ValueVector_t& detValues_up = Dets[0]->detValues;
      ValueVector_t& detValues_dn = Dets[1]->detValues;
      GradMatrix_t& grads_up = Dets[0]->grads;
      GradMatrix_t& grads_dn = Dets[1]->grads;
      ValueMatrix_t& lapls_up = Dets[0]->lapls;
      ValueMatrix_t& lapls_dn = Dets[1]->lapls;
      int N1 = Dets[0]->FirstIndex;
      int N2 = Dets[1]->FirstIndex;
      int NP1 = Dets[0]->NumPtcls;
      int NP2 = Dets[1]->NumPtcls;

      ValueType psi=0.0;
      myG_temp=0.0;
      myL_temp=0.0;
      vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
      vector<RealType>::iterator it(C.begin()),last(C.end());
      while(it != last) {
        psi += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
        for(int k=0,n=N1; k<NP1; k++,n++) {
          myG_temp(n) += (*it)*grads_up(*upC,k)*detValues_dn[*dnC];
          myL_temp(n) += (*it)*lapls_up(*upC,k)*detValues_dn[*dnC];
        }
        for(int k=0,n=N2; k<NP2; k++,n++) {
          myG_temp(n) += (*it)*grads_dn(*dnC,k)*detValues_up[*upC];
          myL_temp(n) += (*it)*lapls_dn(*dnC,k)*detValues_up[*upC];
        }
        it++;upC++;dnC++;
      }
      ValueType psiinv = 1.0/psi;
      myG_temp *= psiinv;
      myL_temp *= psiinv;
  */
}

void MultiSlaterDeterminantFast::restore(int iat)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: restore not implemented. \n");
  }
  AccRejTimer.start();
  Dets[DetID[iat]]->restore(iat);
  curRatio=1.0;
  AccRejTimer.stop();
}

void MultiSlaterDeterminantFast::update(ParticleSet& P
                                        , ParticleSet::ParticleGradient_t& dG, ParticleSet::ParticleLaplacian_t& dL
                                        , int iat)
{
  APP_ABORT("IMPLEMENT MultiSlaterDeterminantFast::update");
}

OrbitalBase::RealType MultiSlaterDeterminantFast::evaluateLog(ParticleSet& P,BufferType& buf)
{
  Dets[0]->evaluateLog(P,buf);
  Dets[1]->evaluateLog(P,buf);
  buf.put(psiCurrent);
  buf.put(myL.first_address(), myL.last_address());
  buf.put(FirstAddressOfG,LastAddressOfG);
  return LogValue = evaluateLogAndPhase(psiCurrent,PhaseValue);
}

OrbitalBase::RealType MultiSlaterDeterminantFast::registerData(ParticleSet& P, BufferType& buf)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: restore not implemented. \n");
  }
  Dets[0]->registerData(P,buf);
  Dets[1]->registerData(P,buf);
  LogValue = evaluateLog(P,P.G,P.L);
  FirstAddressOfG = &myG[0][0];
  LastAddressOfG = FirstAddressOfG + P.getTotalNum()*DIM;
  buf.add(psiCurrent);
  buf.add(myL.first_address(), myL.last_address());
  buf.add(FirstAddressOfG,LastAddressOfG);
// debug, erase
//    msd->registerData(P,buf);
  return LogValue;
}

// this routine does not initialize the data, just reserves the space
void MultiSlaterDeterminantFast::registerDataForDerivatives(ParticleSet& P, BufferType& buf, int storageType)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: registerDataForDerivatives not implemented. \n");
  }
  Dets[0]->registerDataForDerivatives(P,buf,storageType);
  Dets[1]->registerDataForDerivatives(P,buf,storageType);
}

// FIX FIX FIX
OrbitalBase::RealType MultiSlaterDeterminantFast::updateBuffer(ParticleSet& P, BufferType& buf, bool fromscratch)
{
  UpdateTimer.start();
  Dets[0]->updateBuffer(P,buf,fromscratch);
  Dets[1]->updateBuffer(P,buf,fromscratch);
  //Dets[0]->updateBuffer(P,buf,true);
  //Dets[1]->updateBuffer(P,buf,true);
  // can this change over time??? I don't know yet
  ValueVector_t& detValues_up = Dets[0]->detValues;
  ValueVector_t& detValues_dn = Dets[1]->detValues;
  GradMatrix_t& grads_up = Dets[0]->grads;
  GradMatrix_t& grads_dn = Dets[1]->grads;
  ValueMatrix_t& lapls_up = Dets[0]->lapls;
  ValueMatrix_t& lapls_dn = Dets[1]->lapls;
  int N1 = Dets[0]->FirstIndex;
  int N2 = Dets[1]->FirstIndex;
  int NP1 = Dets[0]->NumPtcls;
  int NP2 = Dets[1]->NumPtcls;
  psiCurrent=0.0;
  myG=0.0;
  myL=0.0;
  vector<int>::iterator upC(C2node_up.begin()),dnC(C2node_dn.begin());
  vector<RealType>::iterator it(C.begin()),last(C.end());
  while(it != last)
  {
    psiCurrent += (*it)*detValues_up[*upC]*detValues_dn[*dnC];
    for(int k=0,n=N1; k<NP1; k++,n++)
    {
      myG(n) += (*it)*grads_up(*upC,k)*detValues_dn[*dnC];
      myL(n) += (*it)*lapls_up(*upC,k)*detValues_dn[*dnC];
    }
    for(int k=0,n=N2; k<NP2; k++,n++)
    {
      myG(n) += (*it)*grads_dn(*dnC,k)*detValues_up[*upC];
      myL(n) += (*it)*lapls_dn(*dnC,k)*detValues_up[*upC];
    }
    it++;
    upC++;
    dnC++;
  }
  ValueType psiinv = 1.0/psiCurrent;
  myG *= psiinv;
  myL *= psiinv;
  P.G += myG;
  for(int i=0; i<P.L.size(); i++)
    P.L(i) += myL[i] - dot(myG[i],myG[i]);
  buf.put(psiCurrent);
  buf.put(myL.first_address(), myL.last_address());
  buf.put(FirstAddressOfG,LastAddressOfG);
  UpdateTimer.stop();
  return LogValue = evaluateLogAndPhase(psiCurrent,PhaseValue);
}

void MultiSlaterDeterminantFast::copyFromBuffer(ParticleSet& P, BufferType& buf)
{
  if(usingBF)
  {
    APP_ABORT("Fast MSD+BF: copyFromBuffer not implemented. \n");
  }
  Dets[0]->copyFromBuffer(P,buf);
  Dets[1]->copyFromBuffer(P,buf);
  buf.get(psiCurrent);
  buf.get(myL.first_address(), myL.last_address());
  buf.get(FirstAddressOfG,LastAddressOfG);
}


void MultiSlaterDeterminantFast::checkInVariables(opt_variables_type& active)
{
  if(Optimizable)
  {
    if(myVars.size())
      active.insertFrom(myVars);
    else
      Optimizable=false;
  }
}

void MultiSlaterDeterminantFast::checkOutVariables(const opt_variables_type& active)
{
  if(Optimizable)
    myVars.getIndex(active);
}

/** resetParameters with optVariables
 *
 * USE_resetParameters
 */
void MultiSlaterDeterminantFast::resetParameters(const opt_variables_type& active)
{
  if(Optimizable)
  {
    if(usingCSF)
    {
      for(int i=0; i<CSFcoeff.size()-1; i++)
      {
        int loc=myVars.where(i);
        if(loc>=0)
          CSFcoeff[i+1]=myVars[i]=active[loc];
      }
      int cnt=0;
      for(int i=0; i<DetsPerCSF.size(); i++)
      {
        for(int k=0; k<DetsPerCSF[i]; k++)
        {
          C[cnt] = CSFcoeff[i]*CSFexpansion[cnt];
          cnt++;
        }
      }
      //for(int i=0; i<Dets.size(); i++) Dets[i]->resetParameters(active);
    }
    else
    {
      for(int i=0; i<C.size()-1; i++)
      {
        int loc=myVars.where(i);
        if(loc>=0)
          C[i+1]=myVars[i]=active[loc];
      }
      //for(int i=0; i<Dets.size(); i++) Dets[i]->resetParameters(active);
    }
  }
}
void MultiSlaterDeterminantFast::reportStatus(ostream& os)
{
}

//   OrbitalBasePtr MultiSlaterDeterminantFast::makeClone(ParticleSet& tqp) const
//   {
//      APP_ABORT("IMPLEMENT OrbitalBase::makeClone");
//      return 0;
//   }

void MultiSlaterDeterminantFast::evaluateDerivatives(ParticleSet& P,
    const opt_variables_type& optvars,
    vector<RealType>& dlogpsi,
    vector<RealType>& dhpsioverpsi)
{
  bool recalculate(false);
  for (int k=0; k<myVars.size(); ++k)
  {
    int kk=myVars.where(k);
    if (kk<0)
      continue;
    if (optvars.recompute(kk))
      recalculate=true;
  }
// need to modify for CSF later on, right now assume Slater Det basis
  if (recalculate)
  {
    if(usingCSF)
    {
      if(laplSum_up.size() == 0)
        laplSum_up.resize(Dets[0]->detValues.size());
      if(laplSum_dn.size() == 0)
        laplSum_dn.resize(Dets[1]->detValues.size());
      // assume that evaluateLog has been called in opt routine before
      //   Dets[0]->evaluateForWalkerMove(P);
      //   Dets[1]->evaluateForWalkerMove(P);
      ValueVector_t& detValues_up = Dets[0]->detValues;
      ValueVector_t& detValues_dn = Dets[1]->detValues;
      GradMatrix_t& grads_up = Dets[0]->grads;
      GradMatrix_t& grads_dn = Dets[1]->grads;
      ValueMatrix_t& lapls_up = Dets[0]->lapls;
      ValueMatrix_t& lapls_dn = Dets[1]->lapls;
      int N1 = Dets[0]->FirstIndex;
      int N2 = Dets[1]->FirstIndex;
      int NP1 = Dets[0]->NumPtcls;
      int NP2 = Dets[1]->NumPtcls;
// myG,myL should already be calculated
      int n = P.getTotalNum();
      ValueType psiinv = 1.0/psiCurrent;
      ValueType lapl_sum=0.0;
      ValueType gg=0.0, ggP=0.0;
      myG_temp=0.0;
      int num=laplSum_up.size();
      ValueVector_t::iterator it(laplSum_up.begin());
      ValueVector_t::iterator last(laplSum_up.end());
      ValueType* ptr0 = lapls_up[0];
      while(it != last)
      {
        (*it)=0.0;
        for(int k=0; k<nels_up; k++,ptr0++)
          (*it) += *ptr0;
        it++;
      }
      it=laplSum_dn.begin();
      last=laplSum_dn.end();
      ptr0 = lapls_dn[0];
      while(it != last)
      {
        (*it)=0.0;
        for(int k=0; k<nels_dn; k++,ptr0++)
          (*it) += *ptr0;
        it++;
      }
      for(int i=0; i<C.size(); i++)
      {
        int upC = C2node_up[i];
        int dnC = C2node_dn[i];
        ValueType tmp1 = C[i]*detValues_dn[dnC]*psiinv;
        ValueType tmp2 = C[i]*detValues_up[upC]*psiinv;
        lapl_sum += tmp1*laplSum_up[upC]+tmp2*laplSum_dn[dnC];
        for(int k=0,j=N1; k<NP1; k++,j++)
          myG_temp[j] += tmp1*grads_up(upC,k);
        for(int k=0,j=N2; k<NP2; k++,j++)
          myG_temp[j] += tmp2*grads_dn(dnC,k);
      }
      gg=ggP=0.0;
      for(int i=0; i<n; i++)
      {
        gg += dot(myG_temp[i],myG_temp[i])-dot(P.G[i],myG_temp[i]);
      }
//       for(int i=0; i<C.size(); i++){
      num=CSFcoeff.size()-1;
      int cnt=0;
//        this one is not optable
      cnt+=DetsPerCSF[0];
      int ip(1);
      for(int i=0; i<num; i++,ip++)
      {
        int kk=myVars.where(i);
        if (kk<0)
        {
          cnt+=DetsPerCSF[ip];
          continue;
        }
        ValueType cdet=0.0,q0=0.0,v1=0.0,v2=0.0;
        for(int k=0; k<DetsPerCSF[ip]; k++)
        {
          int upC = C2node_up[cnt];
          int dnC = C2node_dn[cnt];
          ValueType tmp1=CSFexpansion[cnt]*detValues_dn[dnC]*psiinv;
          ValueType tmp2=CSFexpansion[cnt]*detValues_up[upC]*psiinv;
          cdet+=CSFexpansion[cnt]*detValues_up[upC]*detValues_dn[dnC]*psiinv;
          q0 += (tmp1*laplSum_up[upC] + tmp2*laplSum_dn[dnC]);
          for(int l=0,j=N1; l<NP1; l++,j++)
            v1 += tmp1*(dot(P.G[j],grads_up(upC,l))-dot(myG_temp[j],grads_up(upC,l)) );
          for(int l=0,j=N2; l<NP2; l++,j++)
            v2 += tmp2*(dot(P.G[j],grads_dn(dnC,l))-dot(myG_temp[j],grads_dn(dnC,l)));
          cnt++;
        }
        convert(cdet,dlogpsi[kk]);
        ValueType dhpsi =  -0.5*(q0-cdet*lapl_sum)
                           -cdet*gg-v1-v2;
        //ValueType dhpsi =  -0.5*(tmp1*laplSum_up[upC]+tmp2*laplSum_dn[dnC]
        //                         -cdet*lapl_sum)
        //                   -cdet*gg-(tmp1*v1+tmp2*v2);
        convert(dhpsi,dhpsioverpsi[kk]);
      }
    }
    else
      //usingCSF
    {
      if(laplSum_up.size() == 0)
        laplSum_up.resize(Dets[0]->detValues.size());
      if(laplSum_dn.size() == 0)
        laplSum_dn.resize(Dets[1]->detValues.size());
      // assume that evaluateLog has been called in opt routine before
      //   Dets[0]->evaluateForWalkerMove(P);
      //   Dets[1]->evaluateForWalkerMove(P);
      ValueVector_t& detValues_up = Dets[0]->detValues;
      ValueVector_t& detValues_dn = Dets[1]->detValues;
      GradMatrix_t& grads_up = Dets[0]->grads;
      GradMatrix_t& grads_dn = Dets[1]->grads;
      ValueMatrix_t& lapls_up = Dets[0]->lapls;
      ValueMatrix_t& lapls_dn = Dets[1]->lapls;
      int N1 = Dets[0]->FirstIndex;
      int N2 = Dets[1]->FirstIndex;
      int NP1 = Dets[0]->NumPtcls;
      int NP2 = Dets[1]->NumPtcls;
      int n = P.getTotalNum();
      ValueType psiinv = 1.0/psiCurrent;
      ValueType lapl_sum=0.0;
      ValueType gg=0.0, ggP=0.0;
      myG_temp=0.0;
      int num=laplSum_up.size();
      ValueVector_t::iterator it(laplSum_up.begin());
      ValueVector_t::iterator last(laplSum_up.end());
      ValueType* ptr0 = lapls_up[0];
      while(it != last)
      {
        (*it)=0.0;
        for(int k=0; k<nels_up; k++,ptr0++)
          (*it) += *ptr0;
        it++;
      }
      it=laplSum_dn.begin();
      last=laplSum_dn.end();
      ptr0 = lapls_dn[0];
      while(it != last)
      {
        (*it)=0.0;
        for(int k=0; k<nels_dn; k++,ptr0++)
          (*it) += *ptr0;
        it++;
      }
      for(int i=0; i<C.size(); i++)
      {
        int upC = C2node_up[i];
        int dnC = C2node_dn[i];
        ValueType tmp1 = C[i]*detValues_dn[dnC]*psiinv;
        ValueType tmp2 = C[i]*detValues_up[upC]*psiinv;
        lapl_sum += tmp1*laplSum_up[upC]+tmp2*laplSum_dn[dnC];
        for(int k=0,j=N1; k<NP1; k++,j++)
          myG_temp[j] += tmp1*grads_up(upC,k);
        for(int k=0,j=N2; k<NP2; k++,j++)
          myG_temp[j] += tmp2*grads_dn(dnC,k);
      }
      gg=ggP=0.0;
      for(int i=0; i<n; i++)
      {
        gg += dot(myG_temp[i],myG_temp[i])-dot(P.G[i],myG_temp[i]);
      }
      for(int i=1; i<C.size(); i++)
      {
        int kk=myVars.where(i-1);
        if (kk<0)
          continue;
        int upC = C2node_up[i];
        int dnC = C2node_dn[i];
        ValueType cdet=detValues_up[upC]*detValues_dn[dnC]*psiinv;
        ValueType tmp1=detValues_dn[dnC]*psiinv;
        ValueType tmp2=detValues_up[upC]*psiinv;
        convert(cdet,dlogpsi[kk]);
        ValueType v1=0.0,v2=0.0;
        for(int k=0,j=N1; k<NP1; k++,j++)
          v1 += (dot(P.G[j],grads_up(upC,k))-dot(myG_temp[j],grads_up(upC,k)) );
        for(int k=0,j=N2; k<NP2; k++,j++)
          v2 += (dot(P.G[j],grads_dn(dnC,k))-dot(myG_temp[j],grads_dn(dnC,k)));
        ValueType dhpsi =  -0.5*(tmp1*laplSum_up[upC]+tmp2*laplSum_dn[dnC]
                                 -cdet*lapl_sum)
                           -cdet*gg-(tmp1*v1+tmp2*v2);
        convert(dhpsi,dhpsioverpsi[kk]);
      }
    } // usingCSF
  }
}

void MultiSlaterDeterminantFast::registerTimers()
{
  RatioTimer.reset();
  RatioGradTimer.reset();
  RatioAllTimer.reset();
  Ratio1Timer.reset();
  Ratio1GradTimer.reset();
  Ratio1AllTimer.reset();
  UpdateTimer.reset();
  EvaluateTimer.reset();
  AccRejTimer.reset();
  TimerManager.addTimer (&RatioTimer);
  TimerManager.addTimer (&RatioGradTimer);
  TimerManager.addTimer (&RatioAllTimer);
  TimerManager.addTimer (&Ratio1Timer);
  TimerManager.addTimer (&Ratio1GradTimer);
  TimerManager.addTimer (&Ratio1AllTimer);
  TimerManager.addTimer (&UpdateTimer);
  TimerManager.addTimer (&EvaluateTimer);
  TimerManager.addTimer (&AccRejTimer);
}


}
/***************************************************************************
 * $RCSfile$   $Author: jnkim $
 * $Revision: 3416 $   $Date: 2008-12-07 11:34:49 -0600 (Sun, 07 Dec 2008) $
 * $Id: MultiSlaterDeterminantFast.cpp 3416 2008-12-07 17:34:49Z jnkim $
 ***************************************************************************/
